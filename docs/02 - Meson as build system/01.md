# Building our project with meson

As our project scales, we will have to start creating multiple files in order to keep everything organized. This starts being problematic at the time of compiling, because in Vala we would need to repeat the same command in the terminal:

```sh
valac file1.vala file2vala file3.vala file4.vala file5.vala -o app_executable_name --pkg gtk+-3.0
```

Which, is far from being verbose and is quite intimidating, but we can make it way better by using a *build system*. The build system that we are going to use, and also has quite good support for GNOME related stuff.

Consider creating a new folder. We will also see how to extend GTK classes in order to have a more object oriented approach in our projects. This will also help us to create better and more readable code.

First, we are going to create a simple Hello world in terminal in order to get started with meson!

```vala
public static int main () {
    print ("Hello world!\n");
    return 0;
}
```

Now that we have written our lines of code for this sample, let's create the fundamental meson file: `meson.build`.

In order to get started with our program, we have to stablish a project name and the programming language(s) that we will be using. Choose a name for your project, and in programming languages we need **C** and **Vala**.

If you are wondering why C is over there, you may have noticed that a `main.c` often appeared when you were compiling your Vala Code. This is becase Vala precompiles to C, as a intermidate programming language, and then, it compiles to binary. This allows to keep the efficiency of C while writting High-Level code.

```meson
project ('gtk-tutorial', ['c', 'vala'])
```

We wouldn't need the brackets if we were using a single programming language, but as we are now using two of them, we have to write those as an array.

Now, we have to specify the name of our executable, and the list of our files. We can do it this way:

```meson
project ('gtk-tutorial', ['c', 'vala'])
executable ('gtk-tutorial', 'main.vala', install: true)
```

As you can see, we are telling it the name of the executable we want and the list of files. By the way, if you want to have the same file name for your binary file as your project name, you can use the meson method `meson.project_name ()`.

We can, in theory, configure our meson project with the following line of code in your terminal:

```sh
meson builddir
```

And, now, you may be wondering what is `builddir`. Well, is the name of the folder in which our binaries and compiled files will be. You don't really need to understand the whole meson file structure, just keep in mind you'll find your executable over there.

Now, you change your directory to the `builddir` with `cd builddir` command in terminal. To compile your project, you need to run this command:

```sh
ninja
```

Very short command, but now some warnings will appear on the screen that are kind of weird, this is not the expected output. Well, it's because we have missing a dependency, the GObject Introspection. It's time to learn about **meson dependencies**.

We can specify what are the dependencies of our project on the `executable` function. We use the property `dependencies` and then we attach an array of them. But first, how can we get a meson dependency?

Well, there is a built in method named `dependency`, and it returns a meson dependency that we can put in our `dependencies` or in a variable. For example:

```meson
gio_dep = dependency ('gio-2.0', version: '>=2.50')
```

As you can see, the `dependency` method requires that we specify the name of the dependency that will return with this method, and the version of it. We use the `>=` in order to state that the following number is the minimum required dependency version. The variable that we've just declared, called ´gio_dep´ now has the dependency "stored" in it.

Now you can put it this way in your `executable`:

```meson
executable (meson.project_name (), 'main.vala',
	    dependencies: gio_dep,
	    install: true
)
```

As you can see, we are putting in the dependencies section our `gio_dep` variable. Alternatively, you can use:

```meson
executable (meson.project_name (), 'main.vala',
	    dependencies: dependency ('gio-2.0', version: '>=2.50'),
	    install: true
)
```

But this is not that verbose, so I'd recommend you to use the first option with the variable name if you are using a single dependency.

Now, you can run `ninja` again and it should compile just fine. You can run the program by using:

```sh
./file_name
```

But, let's continue with the Vala stuff. Let's use a new object from Gtk: `GtkApplication`. The `GtkApplication` basically calls by itself the `Gtk.main`, sets a default log domain for our terminal messages. So, let's get right into it.

First, let's create a file named `Application.vala`, and let's add the gtk dependency to our meson file. Let's create a variable to store our Gtk Dependency, and we will use the version `3.24` for our project.

```meson
gtk_dep = dependency ('gtk+-3.0', version: '>=3.24')
```

Now, let's tweak the executable section. We need an array of dependencies this time. We can create it within the `dependencies` section this way:

```meson
executable (meson.project_name (), 'main.vala',
	    dependencies: [
	    	gio_dep,
	    	gtk_dep
	    ],
	    install: true
)
```

We have to add the `Application.vala` file to our meson.build. We can list them just as we were doing, but we can use an array stored in a variable with the files we need:

```meson
project_files = [
	'main.vala',
	'Application.vala'
]
```

We can do this with the dependencies too:

```meson
project_deps = [
	dependency ('gio-2.0', version: '>=2.50'),
	dependency ('gtk+-3.0', version: '>=3.24')
]
```

We should replace the file that we had put in the executable part and the dependency array that we had originally used to have something like this:

```meson
executable (meson.project_name (), project_files,
	    dependencies: project_deps,
	    install: true
)
```

As you can see, it looks cleaner, and it also makes it easier to mantain, in my experience.

Now, we can start working in our `Application.vala`. First, we have to extend the class to create ours. We use the format for extending a class:

´´´vala
public class ClassName : ParentClass
´´´

As you can see, the colons are telling us which is the parent class of ´ClassName´. So, to extend the ´GtkApplication´ class, we will do the following:

```vala
public class MyApplication : Gtk.Application {

}
```

We currently have just an empty class, but let's learn about it's constructors. If you have been on OO coding sometime, you know that a class has a constructor. In Vala, we have technically two of them, that I'll briefly explain:

## ClassName ()

In most programming languages, we have a constructor usually defined by the name of the class as a function. In Vala, this constructor returns the ´new´ class to the variable it is being called to. E.g:

´´´vala
my_class = new Namespace.ClassName ();
´´´

Triggers:

´´´vala
public ClassName () {
	print ("Hello World");
}
´´´

